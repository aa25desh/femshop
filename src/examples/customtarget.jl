#=
This contains all of the pieces needed to add a new code gen target.
1. get_custom_language_elements()
2. generate_custom_code_layer()
3. generate_custom_files()
=#

import .Femshop: Femshop_config, Femshop_prob, GenFunction, Variable, Coefficient
import .Femshop: log_entry, printerr
import .Femshop: config, prob, refel, mesh_data, grid_data, genfunctions, variables, coefficients, 
        test_functions, linears, bilinears, time_stepper


function get_custom_language_elements()
    file_extension = ".m";
    comment_char = "%";
    block_comment = ["%{"; "%}"];
    
    return (file_extension, comment_char, block_comment);
end

function generate_custom_code_layer(symex, var, lorr)
    return generate_code_layer_custom(symex, var, lorr);
end

function generate_custom_files(gendir, genfiles, bilinex, linex)
    custom_utils_file(gendir);
    custom_main_file(genfiles);
    custom_config_file(genfiles);
    custom_prob_file(genfiles);
    custom_mesh_file(genfiles);
    custom_genfunction_file(genfiles);
    custom_bilinear_file(genfiles, bilinex);
    custom_linear_file(genfiles, linex);
    custom_stepper_file(genfiles);
end

# numbers: 2 -> "2"
# strings: "thing" -> "'thing'"
# arrays: [1 2; 3 4] -> "[1 2; 3 4]"
function custom_gen_string(v)
    if typeof(v) == String
        return "'"*v*"'";
        
    elseif typeof(v) <: Number
        return string(v);
        
    elseif typeof(v) <: Array
        if ndims(v) == 1 # "[a; b; c]"
            n = length(v);
            str = "[";
            for i=1:n
                str = str*custom_gen_string(v[i]);
                if i < n
                    str = str*"; ";
                end
            end
            str = str*"]";
        elseif ndims(v) == 2 # "[a b ; c d]
            (n,m) = size(v);
            str = "[";
            for i=1:n
                for j=1:m
                    str = str*custom_gen_string(v[i,j])*" ";
                end
                if i < n
                    str = str*"; ";
                end
            end
            str = str*"]";
        end
        return str;
        
    elseif typeof(v) == GenFunction
        return v.name;
    else
        return string(v);
    end
end

# Returns a string like "fread(f, [3, 15], 'double')" for an array with size (3,15) and type Float64
function custom_fread(A)
    if typeof(A) <: Array
        if length(A) == 0
            return "0";
        end
        if typeof(A[1]) == Int
            typ = "\'int64\'";
        else
            typ = "\'double\'";
        end
        if length(size(A)) == 1
            sz = "["*string(length(A))*",1]";
        else
            sz = "["*string(size(A,1))*","*string(size(A,2))*"]";
        end
        return "fread(f, "*sz*", "*typ*")"
    else
        if typeof(A) == Int64
            typ = "\'int64\'";
        else
            typ = "\'double\'";
        end
        return "fread(f, [1], "*typ*")"
    end
end

# produces code to read a binary struct into custom
# The struct is labeled with the name and has the same fieldnames as s
function custom_struct_reader(name, s)
    code = "";
    for fn in fieldnames(typeof(s))
        f = getfield(s,fn);
        if typeof(f) <: Array && length(f) > 0 && typeof(f[1]) <: Array
            code = code * name * "." * string(fn) * " = cell([" * string(length(f)) * ", 1]);\n";
            for i=1:length(f)
                code = code * name * "." * string(fn) * "{" * string(i) * "} = " * custom_fread(f[i]) * ";\n";
            end
        else
            code = code * name * "." * string(fn) * " = " * custom_fread(f) * ";\n";
        end
    end
    return code;
end


function custom_main_file(genfiles)
    file = genfiles.main;
    println(file, "clear;");
    println(file, "");
    # These are always included
    println(file, "");
    println(file, "Utils;");
    println(file, "Config;");
    println(file, "Mesh;");
    println(file, "Genfunction;");
    println(file, "Problem;");
    println(file, "Bilinear;");
    println(file, "Linear;");
    println(file, "");
    
    # This should be generated by solve()
    # Just for testing:
    println(file, "u = LHS\\RHS;");
    println(file, "");
    
    # Output should be generated by finalize?
    # Just for testing:
    #println(file, "N1d = sqrt(mesh_data.nel)*config.basis_order_min+1;");
    #println(file, "surf(reshape(u,N1d,N1d));");
    output = "
gxy = grid_data.allnodes';

X = gxy(:,1);
Y = gxy(:,2);

DT = delaunay(gxy);
Tu = triangulation(DT, X, Y, u);

figure();
trisurf(Tu, 'edgecolor', 'none')
view(2);
"
    println(file, output)
    println(file, "");
    
end

function custom_utils_file(genDir)
    utilsfile = open(genDir*"/src/Utils.m", "w");
    
    content = "
classdef Utils
    
    methods(Static)
        % 2D routines
        function y = tensor_IAX (A, x)
            N = size (A, 1);
            y = A * reshape(x, N, N);
            y = y(:);
        end

        function y = tensor_AIX (A, x)
            N = size (A, 1);
            y = A * reshape(x, N, N)';
            y = y'; 
            y = y(:);
        end

        % 3D routines
        function y = tensor_IIAX (A, x)
            N = size (A, 1);
            y = A * reshape(x, N, N*N);
            y = y(:);
        end

        function y = tensor_IAIX (A, x)
            N = size (A, 1);
            q = reshape(x, N, N, N);
            y = zeros(N,N,N);
            for i=1:N
                y(i,:,:) = A * squeeze( q(i,:,:) );
            end
            y = y(:);
        end

        function y = tensor_AIIX (A, x)
            N = size (A, 1);
            y = reshape(x, N*N, N) * A';
            y = y(:);
        end

        function du = tensor_grad(refel, u)
            du = zeros(length(u), refel.dim);
            if (refel.dim == 2)
                du(:,1) = Utils.tensor_IAX (refel.Dr, u);
                du(:,2) = Utils.tensor_AIX (refel.Dr, u);
            else
                du(:,1) = Utils.tensor_IIAX (refel.Dr, u);
                du(:,2) = Utils.tensor_IAIX (refel.Dr, u);
                du(:,3) = Utils.tensor_AIIX (refel.Dr, u);
            end
        end

        function [dx, dy] = tensor_grad2(A, x)
            dx = Utils.tensor_IAX (A, x);
            dy = Utils.tensor_AIX (A, x);
        end

        function [dx, dy, dz] = tensor_grad3(A, x)
            dx = Utils.tensor_IIAX (A, x);
            dy = Utils.tensor_IAIX (A, x);
            dz = Utils.tensor_AIIX (A, x);
        end


        function [J, D] = geometric_factors(refel, pts)

            if (refel.dim == 0)
                xr  = [1];
                J = xr;
            elseif (refel.dim == 1)
                xr  = refel.Dr*pts;
                J = xr;
            elseif (refel.dim == 2)
                if refel.Nfaces == 3 % triangle
                    xr = refel.Ddr*pts(1,:)';
                    xs = refel.Dds*pts(1,:)';
                    yr = refel.Ddr*pts(2,:)';
                    ys = refel.Dds*pts(2,:)';
                    J = -xs.*yr + xr.*ys;
                    J = J(1); 
                else % quad
                    [xr, xs] = Utils.tensor_grad2 (refel.Dg, pts(1,:));
                    [yr, ys] = Utils.tensor_grad2 (refel.Dg, pts(2,:));

                    J = -xs.*yr + xr.*ys;
                end

            else
                [xr, xs, xt] = Utils.tensor_grad3 (refel.Dg, pts(1,:));
                [yr, ys, yt] = Utils.tensor_grad3 (refel.Dg, pts(2,:));
                [zr, zs, zt] = Utils.tensor_grad3 (refel.Dg, pts(3,:));

                J = xr.*(ys.*zt-zs.*yt) - yr.*(xs.*zt-zs.*xt) + zr.*(xs.*yt-ys.*xt);
            end

            if (nargout > 1)
                if (refel.dim == 1)
                    D.rx = 1./J;
                elseif (refel.dim == 2)
                    if refel.Nfaces == 3 % triangle
                        D.rx =  ys./J;
                        D.sx = -yr./J;
                        D.ry = -xs./J;
                        D.sy =  xr./J;
                    else % quad
                        D.rx =  ys./J;
                        D.sx = -yr./J;
                        D.ry = -xs./J;
                        D.sy =  xr./J;
                    end

                else
                    D.rx =  (ys.*zt - zs.*yt)./J;
                    D.ry = -(xs.*zt - zs.*xt)./J;
                    D.rz =  (xs.*yt - ys.*xt)./J;

                    D.sx = -(yr.*zt - zr.*yt)./J;
                    D.sy =  (xr.*zt - zr.*xt)./J;
                    D.sz = -(xr.*yt - yr.*xt)./J;

                    D.tx =  (yr.*zs - zr.*ys)./J;
                    D.ty = -(xr.*zs - zr.*xs)./J;
                    D.tz =  (xr.*ys - yr.*xs)./J;
                end

            end
        end
        
        % pack and unpack variables into a global vector
        % packed vars are in a vector, unpacked are in a cell table
        function pk = pack_vars(upk, pk)
            for i=1:Nvars
                pk(i:Nvars:length(pk)) = upk{i};
            end
        end
        
        function upk = unpack_vars(pk)
            upk = cell(Nvars,1);
            for i=1:Nvars
                upk{i} = pk(i:Nvars:length(pk));
            end
        end
    end
end

"
    println(utilsfile, content);
end

function custom_config_file(genfiles)
    file = genfiles.config;
    # Duplicate the config struct
    for f in fieldnames(Femshop.Femshop_config)
        println(file, "config."*string(f)*" = "*custom_gen_string(getfield(Femshop.config, f))*";");
    end
    println(file, "order = config.basis_order_min;");
end

function custom_prob_file(genfiles)
    file = genfiles.problem;
    # Duplicate the prob struct
    for f in fieldnames(Femshop.Femshop_prob)
        println(file, "prob."*string(f)*" = "*custom_gen_string(getfield(Femshop.prob, f))*";");
    end
end

#=
The mesh file contains any code related to setting up the mesh.
The meshdata file contains all of the data from the Refel, MeshData and Grid structs
These are to be read into custom by a custom custom function in the mesh file.
=#
function custom_mesh_file(genfiles)
    file = genfiles.mesh;
    
    println(file, "f = fopen('MeshData','r');");
    println(file, "% Reference element");
    println(file, custom_struct_reader("refel", refel));
    println(file, "% mesh data");
    println(file, custom_struct_reader("mesh_data", mesh_data));
    println(file, "% grid data");
    println(file, custom_struct_reader("grid_data", grid_data));
    println(file, "fclose(f);");
    
    file = genfiles.meshdata;
    # refel
    Femshop.CodeGenerator.write_binary_struct(file, refel);
    # mesh_data
    Femshop.CodeGenerator.write_binary_struct(file, mesh_data);
    # grid_data
    Femshop.CodeGenerator.write_binary_struct(file, grid_data);
end

function custom_genfunction_file(genfiles)
    file = genfiles.genfunction;
    
    for i = 1:length(genfunctions)
        println(file, genfunctions[i].name*"_fun = @(x,y,z,t) ("*genfunctions[i].str*");");
        # Evaluate them at grid points and make them vectors. Make sense???
        println(file, genfunctions[i].name*" = evaluate_genfun("*genfunctions[i].name*"_fun, grid_data.allnodes, 0);");
    end
    
    # assign variable and coefficient symbols to these vectors
    nvars = 0
    for v in variables
        println(file, string(v.symbol)*" = '"*string(v.symbol)*"';");
        nvars += size(v.values,1);
    end
    println(file, "Nvars = " * string(nvars));
    for v in coefficients
        if typeof(v.value[1]) == GenFunction
            println(file, string(v.symbol)*" = "*v.value[1].name*";");
        else
            println(file, string(v.symbol)*" = "*string(v.value[1])*";");
        end
    end
    
    evalgenfun = 
"""
function u = evaluate_genfun(genfun, pts, t)
    n = size(pts,2);
    dim = size(pts,1);
    u = zeros(n,1);
    x = 0;
    y = 0;
    z = 0;
    for i=1:n
        x = pts(1,i);
        if dim > 1
            y = pts(2,i);
            if dim > 2
                z = pts(3,i);
            end
        end
        u(i) = genfun(x,y,z,t);
    end
end
"""
    println(file, evalgenfun);
    
end

function custom_bilinear_file(genfiles, code)
    file = genfiles.bilinear;
    # insert the code part into this skeleton
    content = 
"
dof = size(grid_data.allnodes,2);
ne  = mesh_data.nel;
Np = refel.Np;
I = zeros(ne * Np*Np, 1);
J = zeros(ne * Np*Np, 1);
val = zeros(ne * Np*Np, 1);

% loop over elements
for e=1:ne
    idx = grid_data.loc2glb(:,e)\';
    pts = grid_data.allnodes(:,idx);
    [detJ, Jac]  = Utils.geometric_factors(refel, pts);
    
    ind1 = repmat(idx,Np,1);
    ind2 = reshape(repmat(idx',Np,1),Np*Np,1);
    st = (e-1)*Np*Np+1;
    en = e*Np*Np;
    I(st:en) = ind1;
    J(st:en) = ind2;\n"*code*"\n
    val(st:en) = elMat(:);
end
LHS = sparse(I,J,val,dof,dof);";
    println(file, content);
    
    # boundary condition
    println(file, "
for i=1:length(grid_data.bdry)
    LHS(grid_data.bdry{i},:) = 0;
    LHS((size(LHS,1)+1)*(grid_data.bdry{i}-1)+1) = 1;
end"); # dirichlet bc
end

function custom_linear_file(genfiles, code)
    file = genfiles.linear;
    # insert the code part into this skeleton
    content = 
"
dof = size(grid_data.allnodes,2);
ne  = mesh_data.nel;
Np = refel.Np;
RHS = zeros(dof,1);

% loop over elements
for e=1:ne
    idx = grid_data.loc2glb(:,e)\';
    pts = grid_data.allnodes(:,idx);
    [detJ, Jac]  = Utils.geometric_factors(refel, pts);
    \n"*code*"\n
    RHS(idx) = elVec;
end
";
    println(file, content);
    
    # boundary condition
    println(file, "
for i=1:length(grid_data.bdry)
    RHS(grid_data.bdry{i}) = prob.bc_func(grid_data.bdry{i});
end"); # dirichlet bc
end

function custom_stepper_file(genfiles)
    file = genfiles.stepper;
end



# This is the same as custom
function generate_code_layer_custom(symex, var, lorr)
    code = ""; # the code will be in this string
    
    need_derivative = false;
    term_derivative = [];
    needed_coef = [];
    needed_coef_ind = [];
    test_ind = [];
    trial_ind = [];
    
    # symex is an array of arrays of symengine terms
    # turn each one into an Expr
    terms = [];
    sz = size(symex);
    if length(sz) == 1 # scalar or vector
        for i=1:length(symex)
            for ti=1:length(symex[i])
                push!(terms, Meta.parse(string(symex[i][ti])));
            end
        end
    elseif length(sz) == 2 # matrix
        #TODO
    end
    
    # Process the terms turning them into the code layer
    # cindex = 0;
    # for i=1:length(terms)
    #     (codeterm, der, coe) = process_term_dendro(terms[i], cindex, length(terms), i, var, lorr);
    #     need_derivative = need_derivative || der;
    #     push!(term_derivative, der);
    #     append!(needed_coef, coe);
    #     cindex = length(needed_coef);
    #     push!(code_terms, codeterm);
    # end
    # Process the terms turning them into the code layer
    code_terms = [];
    for i=1:length(terms)
        (codeterm, der, coe, coeind, testi, trialj) = process_term_custom(terms[i], var, lorr);
        if coeind == -1
            # processing failed due to nonlinear term
            printerr("term processing failed for: "*string(terms[i]));
            return nothing;
        end
        need_derivative = need_derivative || der;
        append!(needed_coef, coe);
        append!(needed_coef_ind, coeind);
        # change indices into one number
        
        push!(test_ind, testi);
        push!(trial_ind, trialj);
        push!(code_terms, codeterm);
    end
    
    # If coefficients need to be computed, do so
    # # First remove duplicates
    unique_coef = [];
    unique_coef_ind = [];
    for i=1:length(needed_coef)
        already = false;
        for j=1:length(unique_coef)
            if unique_coef[j] === needed_coef[i] && unique_coef_ind[j] == needed_coef_ind[i]
                already = true;
            end
        end
        if !already
            push!(unique_coef, needed_coef[i]);
            push!(unique_coef_ind, needed_coef_ind[i]);
        end
    end
    needed_coef = unique_coef;
    needed_coef_ind = unique_coef_ind;
    
    # For constant coefficients, this generates something like:
    ######################################
    # double coef_n_i = a_i;
    ######################################
    
    # For variable coefficients, this generates something like:
    ######################################
    # double* coef_n_i = new double[nPe];
    # double val;
    # for(unsigned int i=0; i<nPe; i++){
    #     a_i(coords[i*3+0], coords[i*3+0], coords[i*3+0], &val);
    #     coef_n_i[coefi] = val;
    # }
    ######################################
    coef_alloc = "";
    coef_loop = "";
    if length(needed_coef) > 0
        for i=1:length(needed_coef)
            if !(typeof(needed_coef[i]) <: Number || needed_coef[i] === :dt)
                cind = Femshop.CodeGenerator.get_coef_index(needed_coef[i]);
                if cind < 0
                    # probably a variable
                    cind = string(needed_coef[i]);
                    # This presents a problem in dendro. TODO
                    printerr("custom not yet available for multivariate problems. Expect an error.");
                end
                # The string name for this coefficient
                cname = "coef_"*string(cind)*"_"*string(needed_coef_ind[i]);
                
                (ctype, cval) = Femshop.CodeGenerator.get_coef_val(needed_coef[i], needed_coef_ind[i]);
                
                if ctype == 1
                    # constant coefficient -> coef_n_i = cval
                    coef_alloc *= cname*" = "*string(cval)*";\n";
                    
                elseif ctype == 2
                    # genfunction coefficients -> coef_n_i = coef(idx)
                    coef_loop *= cname*" = "*genfunctions[cval].name*"(idx);\n";
                    
                elseif ctype == 3
                    # variable values -> coef_n = variable.values
                    #TODO THIS IS AN ERROR. multivariate support needed.
                end
                
            end
        end
    end
    
    dofsper = 1;
    if typeof(var) <: Array
        for vi=1:length(var)
            dofsper += length(var[vi].symvar.vals); # The number of components for this variable
        end
    elseif !(var.type == SCALAR)
        dofsper = length(var.symvar.vals);
    end
    # Not ready
    if dofsper > 1
        printerr("custom not ready for multi dofs per node. Expect errors");
    end
    
    # Put the pieces together
    code = coef_loop*"\n";
    if lorr == LHS
        code *= "elMat = "*code_terms[1];
        for i=2:length(code_terms)
            code *= " + "*code_terms[i];
        end
        code *= ";\n";
    else
        code *= "elVec = "*code_terms[1];
        for i=2:length(code_terms)
            code *= " + "*code_terms[i];
        end
        code *= ";\n";
    end
    
    return code;
end

# Changes the symbolic layer term into a code layer term
# also records derivative and coefficient needs
function process_term_custom(sterm, var, lorr)
    term = copy(sterm);
    need_derivative = false;
    needed_coef = [];
    needed_coef_ind = [];
    
    test_part = "";
    trial_part = "";
    coef_part = "";
    test_component = 0;
    trial_component = 0;
    deriv_dir = 0;
    
    # extract each of the factors.
    factors = Femshop.CodeGenerator.separate_factors(term);
    
    # strip off all negatives, combine and reattach at the end
    neg = false;
    for i=1:length(factors)
        if typeof(factors[i]) == Expr && factors[i].args[1] === :- && length(factors[i].args) == 2
            neg = !neg;
            factors[i] = factors[i].args[2];
        end
    end
    
    # Separate factors into test/trial/coefficient parts
    coef_facs = [];
    coef_inds = [];
    for i=1:length(factors)
        (index, v, mods) = Femshop.CodeGenerator.extract_symbols(factors[i]);
        
        if Femshop.CodeGenerator.is_test_func(v)
            test_component = index; # the vector index
            if length(mods) > 0
                # TODO more than one derivative mod
                need_derivative = true;
                deriv_dir = parse(Int, mods[1][2]);
                if deriv_dir == 1
                    if config.dimension == 1
                        test_part = "(diag(Jac.rx) * refel.Qr)\'";
                    elseif config.dimension == 2
                        test_part = "([diag(Jac.rx) diag(Jac.sx)] * [refel.Qr; refel.Qs])\'";
                    else
                        test_part = "([diag(Jac.rx) diag(Jac.sx) diag(Jac.tx)] * [refel.Qr; refel.Qs; refel.Qt])\'";
                    end
                elseif deriv_dir == 2
                    if config.dimension == 2
                        test_part = "([diag(Jac.ry) diag(Jac.sy)] * [refel.Qr; refel.Qs])\'";
                    else
                        test_part = "([diag(Jac.ry) diag(Jac.sy) diag(Jac.ty)] * [refel.Qr; refel.Qs; refel.Qt])\'";
                    end
                elseif deriv_dir == 3
                    if config.dimension == 2
                        test_part = "([diag(Jac.rz) diag(Jac.sz)] * [refel.Qr; refel.Qs])\'";
                    else
                        test_part = "([diag(Jac.rz) diag(Jac.sz) diag(Jac.tz)] * [refel.Qr; refel.Qs; refel.Qt])\'";
                    end
                elseif deriv_dir == 4
                    # This will eventually be a time derivative
                    printerr("Derivative index problem in "*string(factors[i]));
                else
                    printerr("Derivative index problem in "*string(factors[i]));
                end
            else
                # no derivative mods
                test_part = "refel.Q\'";
            end
        elseif Femshop.CodeGenerator.is_unknown_var(v, var)
            if !(trial_part == "")
                # Two unknowns multiplied in this term. Nonlinear. abort.
                printerr("Nonlinear term. Code layer incomplete.");
                return (-1, -1, -1, -1, -1, -1);
            end
            trial_component = index;
            if length(mods) > 0
                # TODO more than one derivative mod
                need_derivative = true;
                deriv_dir = parse(Int, mods[1][2]);
                if deriv_dir == 1
                    if config.dimension == 1
                        trial_part = "diag(Jac.rx) * refel.Qr";
                    elseif config.dimension == 2
                        trial_part = "[diag(Jac.rx) diag(Jac.sx)] * [refel.Qr; refel.Qs]";
                    else
                        trial_part = "[diag(Jac.rx) diag(Jac.sx) diag(Jac.tx)] * [refel.Qr; refel.Qs; refel.Qt]";
                    end
                elseif deriv_dir == 2
                    if config.dimension == 2
                        trial_part = "[diag(Jac.ry) diag(Jac.sy)] * [refel.Qr; refel.Qs]";
                    else
                        trial_part = "[diag(Jac.ry) diag(Jac.sy) diag(Jac.ty)] * [refel.Qr; refel.Qs; refel.Qt]";
                    end
                elseif deriv_dir == 3
                    if config.dimension == 2
                        trial_part = "[diag(Jac.rz) diag(Jac.sz)] * [refel.Qr; refel.Qs]";
                    else
                        trial_part = "[diag(Jac.rz) diag(Jac.sz) diag(Jac.tz)] * [refel.Qr; refel.Qs; refel.Qt]";
                    end
                elseif deriv_dir == 4
                    # This will eventually be a time derivative
                    printerr("Derivative index problem in "*string(factors[i]));
                else
                    printerr("Derivative index problem in "*string(factors[i]));
                end
            else
                # no derivative mods
                trial_part = "refel.Q";
            end
        else
            if length(index) == 1
                ind = index[1];
            end
            push!(coef_facs, v);
            push!(coef_inds, ind);
        end
    end
    
    # If rhs, change var into var.values and treat as a coefficient
    if lorr == RHS && !(trial_part === nothing)
        # tmpv = :(a.values[gbl]);
        # tmpv.args[1].args[1] = var.symbol; #TODO, will not work for var=array
        # push!(coef_facs, tmpv);
        # push!(coef_inds, trial_component);
    end
    
    # If there was no trial part, it's an RHS and we need to finish the quadrature with this
    if trial_part == ""
        trial_part = "refel.Q";
    end
    
    # build weight/coefficient parts
    weight_part = "refel.wg .* detJ";
    
    # If term is negative, apply it here
    if neg
        weight_part = "-"*weight_part;
    end
    
    # coefficients
    if length(coef_facs) > 0
        for j=1:length(coef_facs)
            tmp = coef_facs[j];
            if typeof(tmp) == Symbol && !(tmp ===:dt)
                push!(needed_coef, tmp);
                push!(needed_coef_ind, coef_inds[j]);
                ind = Femshop.CodeGenerator.get_coef_index(coef_facs[j]);
                if ind >= 0
                    tmp = "coef_"*string(ind)*"_"*string(coef_inds[j]);
                else
                    tmp = "coef_"*string(tmp)*"_"*string(coef_inds[j]);
                end
            else
                tmp = string(tmp);
            end
            if j>1
                coef_part = coef_part*".*"*tmp;
            else
                coef_part = coef_part*tmp;
            end
        end
    end
    
    # Put the pieces togetherd
    if !(coef_part === "")
        if lorr == LHS
            weight_part = weight_part*" .* "*coef_part;
            weight_part = "diag("*weight_part*")";
            term = test_part * " * " *  weight_part * " * " *  trial_part;
        else # RHS
            weight_part = "diag("*weight_part*")";
            term = test_part * " * " *  weight_part * " * (" *  trial_part *" * "* coef_part *")";
        end
    else
        weight_part = "diag("*weight_part*")";
        term = test_part * " * " *  weight_part * " * " *  trial_part;
    end
    
    return (term, need_derivative, needed_coef, needed_coef_ind, test_component, trial_component);
end
