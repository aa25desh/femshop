######################################
# Femshop Log for: heat2d
######################################

1.	Set time stepper to Euler-implicit
2.	Building simple quad mesh with nx*nx elements, nx=15
3.	Added mesh with 256 vertices and 225 elements.
4.	Full grid has 1922 nodes.
5.	Grid building took 1.0925953 seconds
6.	Added variable: u of type: scalar
7.	Set test function symbol: v of type: scalar
8.	Generated function: genfunction_0
9.	Initial condition for u : GenFunction("genfunction_0", "x=0,y=0,z=0,t=0", "abs(x-0.5)+abs(y-0.5) < 0.2 ? 1 : 0", :(if abs(x - 0.5) + abs(y - 0.5) < 0.2
      1
  else
      0
  end), genfunction_0)
10.	Boundary condition: var=u bid=1 type=Dirichlet val=0
11.	Generated function: genfunction_1
12.	Added coefficient f : sin(6*pi*x)*sin(6*pi*y)
13.	Making weak form for variable(s): u
14.	Weak form, input: Dt(u*v) + 0.01 * dot(grad(u),grad(v)) - f*v
15.	Weak form, symbolic layer: Dt(Array[SymEngine.Basic[_v_1*_u_1]]) + Array[SymEngine.Basic[0.01*D1__u_1*D1__v_1, 0.01*D2__u_1*D2__v_1]] = Array[SymEngine.Basic[_v_1*_f_1]]
16.	Weak form, modified for time stepping: Array{SymEngine.Basic,1}[[_v_1*_u_1, 0.01*dt*D1__u_1*D1__v_1, 0.01*dt*D2__u_1*D2__v_1]] = Array{SymEngine.Basic,1}[[dt*_v_1*_f_1, _v_1*_u_1]]
17.	Weak form, symbolic layer:
lhs = _v_1*_u_1 + 0.01*dt*D1__u_1*D1__v_1 + 0.01*dt*D2__u_1*D2__v_1
rhs = dt*_v_1*_f_1 + _v_1*_u_1
18.	Weak form, code layer: LHS = begin
    var = args[1]
    x = args[2]
    gbl = args[3]
    refel = args[4]
    borl = args[5]
    time = args[6]
    dt = args[7]
    (detJ, J) = geometric_factors(refel, x)
    R1matrix = [diagm(J.rx) diagm(J.sx)]
    Q1matrix = [refel.Qr; refel.Qs]
    R2matrix = [diagm(J.ry) diagm(J.sy)]
    Q2matrix = [refel.Qr; refel.Qs]
    return (refel.Q)' * diagm(refel.wg .* detJ) * refel.Q + transpose(R1matrix * Q1matrix) * (diagm((refel.wg .* detJ) .* (0.01 .* dt)) * (R1matrix * Q1matrix)) + transpose(R2matrix * Q2matrix) * (diagm((refel.wg .* detJ) .* (0.01 .* dt)) * (R2matrix * Q2matrix))
end 
  RHS = begin
    var = args[1]
    x = args[2]
    gbl = args[3]
    refel = args[4]
    borl = args[5]
    time = args[6]
    dt = args[7]
    (detJ, J) = geometric_factors(refel, x)
    coef_0_1 = zeros(refel.Np)
    for coefi = 1:refel.Np
        coef_0_1[coefi] = (f.value[1]).func(x[coefi, 1], x[coefi, 2], 0, time)
    end
    return (refel.Q)' * (diagm(refel.wg .* detJ) * (refel.Q * (dt .* coef_0_1))) + (refel.Q)' * (diagm(refel.wg .* detJ) * (refel.Q * u.values[gbl]))
end
19.	Generated function: genfunction_2
20.	Generated function: genfunction_3
21.	Built initial conditions for: u
22.	Assembly took 0.412646599 seconds
23.	Beginning 3600.0 time steps.
24.	Solve took 29.604000091552734 seconds
25.	Solved for u.(took 30.076766 seconds)
26.	Dumping configuration:
27.		dimension = 2
28.		geometry = square
29.		mesh_type = unstructured
30.		solver_type = CG
31.		trial_function = Legendre
32.		test_function = Legendre
33.		elemental_nodes = Lobatto
34.		quadrature = Gauss
35.		p_adaptive = false
36.		basis_order_min = 2
37.		basis_order_max = 2
38.		linear = true
39.		t_adaptive = false
40.		stepper = Euler-implicit
41.		linalg_matrixfree = false
42.		linalg_backend = ours
43.		output_format = vtk
44.	Dumping problem:
45.		bc_type = ["Dirichlet"]
46.		bid = [1]
47.		bc_func = Any[0]
48.		time_dependent = true
49.		end_time = 1.0
50.		initial = Any[GenFunction("genfunction_0", "x=0,y=0,z=0,t=0", "abs(x-0.5)+abs(y-0.5) < 0.2 ? 1 : 0", :(if abs(x - 0.5) + abs(y - 0.5) < 0.2
      1
  else
      0
  end), genfunction_0)]
51.		lhs_time_deriv = Bool[]
52.	Completed. Closing Log.
